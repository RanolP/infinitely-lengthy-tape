import { readFileSync, writeFileSync } from 'node:fs';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const symPath = resolve(__dirname, '../packages/editor-core/data/sym.txt');
const variantPath = resolve(__dirname, '../packages/editor-core/data/variant.txt');
const outputPath = resolve(__dirname, '../packages/editor-core/src/symbols.ts');

const raw = readFileSync(symPath, 'utf-8');
const lines = raw.split('\n');

interface SymEntry {
  name: string;
  char: string;
}

const entries: SymEntry[] = [];
let parent = '';

for (const line of lines) {
  // Skip blank lines and comments
  if (line.trim() === '' || line.trim().startsWith('//')) continue;

  const indented = line.startsWith('  ');

  if (indented) {
    // Indented line: .suffix char
    const trimmed = line.trim();
    const match = trimmed.match(/^(\.\S+)\s+(.+)$/);
    if (!match) continue; // parent-only suffix or malformed
    const suffix = match[1]!;
    const charPart = match[2]!;
    const resolved = resolveChar(charPart);
    if (resolved) {
      entries.push({ name: parent + suffix, char: resolved });
    }
  } else {
    // Non-indented line: name [char]
    const match = line.match(/^(\S+)(?:\s+(.+))?$/);
    if (!match) continue;
    const name = match[1]!;
    parent = name;
    const charPart = match[2];
    if (charPart) {
      const resolved = resolveChar(charPart);
      if (resolved) {
        entries.push({ name, char: resolved });
      }
    }
  }
}

function resolveChar(raw: string): string | null {
  // Strip variant selector annotations like \vs{text} or \vs{1}
  const cleaned = raw.replace(/\\vs\{[^}]*\}/g, '').trim();
  if (!cleaned) return null;

  // Handle \u{XXXX} escapes
  if (cleaned.startsWith('\\u{')) {
    const hex = cleaned.slice(3, -1);
    const cp = parseInt(hex, 16);
    if (isNaN(cp)) return null;
    return String.fromCodePoint(cp);
  }

  // Direct Unicode character(s)
  return cleaned;
}

// Parse variant.txt for styled letter variants
const variantRaw = readFileSync(variantPath, 'utf-8');
const variantLines = variantRaw.split('\n');

// Only frak/cal from variant.txt — bold/italic are handled at runtime via <b>/<i>
const variantAliases: { suffix: string; long: string; short: string }[] = [
  { suffix: '.frak', long: 'frak', short: 'f' },
  { suffix: '.cal', long: 'cal', short: 'c' },
];

{
  let vParent = '';
  const variantMap = new Map<string, Map<string, string>>();

  for (const line of variantLines) {
    if (line.trim() === '' || line.trim().startsWith('//')) continue;

    const indented = line.startsWith('  ');
    if (indented) {
      const trimmed = line.trim();
      const match = trimmed.match(/^(\.\S+)\s+(.+)$/);
      if (!match) continue;
      const suffix = match[1]!;
      const char = match[2]!;
      let map = variantMap.get(vParent);
      if (!map) {
        map = new Map();
        variantMap.set(vParent, map);
      }
      map.set(suffix, char);
    } else {
      const match = line.match(/^(\S+)/);
      if (match) vParent = match[1]!;
    }
  }

  // Add base letter entries (A-Z, a-z) so runtime bold/italic can find them
  for (const letter of variantMap.keys()) {
    entries.push({ name: letter, char: letter });
  }

  for (const [letter, suffixes] of variantMap) {
    for (const { suffix, long, short } of variantAliases) {
      const char = suffixes.get(suffix);
      if (!char) continue;
      entries.push({ name: `${letter}.${long}`, char });
      entries.push({ name: `${letter}.${short}`, char });
    }
  }
}

// Generate output
const lines_out: string[] = [];
lines_out.push('// Auto-generated by scripts/gen-symbols.ts — do not edit');
lines_out.push('');
lines_out.push('export interface SymbolEntry {');
lines_out.push('  readonly name: string;');
lines_out.push('  readonly char: string;');
lines_out.push('}');
lines_out.push('');
lines_out.push('export const symbols: readonly SymbolEntry[] = [');
for (const entry of entries) {
  const nameEsc = entry.name.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
  const charEsc = entry.char.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
  lines_out.push(`  { name: '${nameEsc}', char: '${charEsc}' },`);
}
lines_out.push('];');
lines_out.push('');

writeFileSync(outputPath, lines_out.join('\n'), 'utf-8');
console.log(`Generated ${entries.length} symbol entries → ${outputPath}`);
